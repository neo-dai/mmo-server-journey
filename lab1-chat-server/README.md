# Lab1: 聊天室服务器开发计划

## 项目概述

这是MMO服务器的"Helloworld"。所有MMO都离不开网络通信和状态广播。

**项目目标**：实现一个支持多房间、支持公屏和私聊的聊天服务器。

**MMO关联技能**：
- **网络编程**：掌握 TCP 或 WebSocket，了解 Socket 编程
- **连接管理**：如何维护一个"在线用户列表"（Connection Pool）
- **消息广播**：如何高效地把一条消息推送给成百上千个连接
- **协议设计**：定义简单的消息格式（例如用JSON或Protobuf）

---

## 版本开发计划

### 📌 版本 0.1：最小可用原型（MVP）
**目标**：建立最基本的客户端-服务器通信

**功能点**：
- [ ] 服务器启动，监听指定端口（如 8080）
- [ ] 客户端可以连接到服务器（TCP 或 WebSocket）
- [ ] 客户端发送消息，服务器原样返回（Echo）
- [ ] 定义基础消息协议格式（JSON）

**验收标准**：
- 客户端连接后，发送 `{"type": "test", "message": "hello"}`，服务器返回相同内容
- 支持多个客户端同时连接

**技术要点**：
- 选择技术栈（Go/Node.js/Python等）
- 实现基础的 Socket 监听和连接处理
- 定义消息协议结构

---

### 📌 版本 0.2：基础聊天室（无状态）
**目标**：实现最简单的多人聊天功能

**功能点**：
- [ ] 客户端连接时设置昵称（name）
- [ ] 服务器维护在线用户列表（内存中）
- [ ] 用户发送消息，广播给所有在线用户
- [ ] 用户上线/下线时，通知其他用户

**消息协议示例**：
```json
// 客户端设置昵称
{"type": "set_name", "name": "Alice"}

// 客户端发送消息
{"type": "chat", "message": "大家好！"}

// 服务器广播消息
{"type": "broadcast", "from": "Alice", "message": "大家好！", "timestamp": 1234567890}

// 用户上线通知
{"type": "user_joined", "name": "Bob"}

// 用户下线通知
{"type": "user_left", "name": "Bob"}
```

**验收标准**：
- 用户A设置昵称后发送消息，用户B和C都能收到
- 用户D上线时，A、B、C收到通知
- 用户A下线时，B、C收到通知

**技术要点**：
- 连接池管理（Connection Pool）
- 消息广播机制
- 简单的状态管理（内存中的用户列表）

---

### 📌 版本 0.3：分组/频道功能（无状态）
**目标**：支持创建和加入不同的聊天分组

**功能点**：
- [ ] 用户可以创建分组（如 `/create trade`）
- [ ] 用户可以加入分组（如 `/join trade`）
- [ ] 用户可以离开分组（如 `/leave trade`）
- [ ] 用户发送消息时，只发送到当前所在分组
- [ ] 用户可以查看所有可用分组列表
- [ ] 默认有一个"大厅"分组，所有用户自动加入

**消息协议扩展**：
```json
// 创建分组
{"type": "create_group", "group_name": "trade"}

// 加入分组
{"type": "join_group", "group_name": "trade"}

// 离开分组
{"type": "leave_group", "group_name": "trade"}

// 查看分组列表
{"type": "list_groups"}

// 分组消息（只在组内广播）
{"type": "group_message", "group": "trade", "from": "Alice", "message": "卖装备！"}
```

**验收标准**：
- 用户A创建"trade"分组，用户B可以加入
- 用户A在"trade"分组发消息，只有该分组内的用户收到
- 用户C在"大厅"分组发消息，用户A和B（如果不在大厅）收不到
- 用户可以同时加入多个分组

**技术要点**：
- 分组管理（Group Manager）
- 用户-分组的多对多关系
- 消息路由（根据分组过滤接收者）

---

### 📌 版本 0.4：私聊功能
**目标**：支持用户之间的点对点私聊

**功能点**：
- [ ] 用户可以查看在线用户列表
- [ ] 用户可以向指定用户发送私聊消息（如 `/w Bob 你好`）
- [ ] 私聊消息只发送给目标用户
- [ ] 支持私聊历史记录（可选，内存中）

**消息协议扩展**：
```json
// 查看在线用户
{"type": "list_users"}

// 发送私聊
{"type": "whisper", "to": "Bob", "message": "你好"}

// 接收私聊
{"type": "whisper", "from": "Alice", "message": "你好", "timestamp": 1234567890}
```

**验收标准**：
- 用户A向用户B发送私聊，只有B收到
- 用户C看不到A和B的私聊内容
- 可以查看当前所有在线用户

**技术要点**：
- 用户查找（根据昵称）
- 点对点消息路由

---

### 📌 版本 0.5：登录/注册系统
**目标**：实现用户账号系统，替代简单的昵称设置

**功能点**：
- [ ] 用户注册（用户名 + 密码）
- [ ] 用户登录（用户名 + 密码验证）
- [ ] 密码存储（简单哈希，如 bcrypt）
- [ ] 登录状态管理
- [ ] 未登录用户无法发送消息

**数据存储**：
- 使用文件（JSON）或简单数据库（SQLite）存储用户信息
- 表结构：`users(id, username, password_hash, created_at)`

**消息协议扩展**：
```json
// 注册
{"type": "register", "username": "alice", "password": "123456"}

// 登录
{"type": "login", "username": "alice", "password": "123456"}

// 登录成功
{"type": "login_success", "username": "alice", "user_id": 1}

// 登录失败
{"type": "login_failed", "reason": "wrong_password"}
```

**验收标准**：
- 用户可以注册新账号
- 注册后可以登录
- 错误密码无法登录
- 未登录用户连接后只能看到登录提示

**技术要点**：
- 密码哈希和验证
- 简单的数据持久化
- 会话管理

---

### 📌 版本 0.6：好友系统
**目标**：实现用户之间的好友关系

**功能点**：
- [ ] 用户A可以添加用户B为好友（如 `/add_friend Bob`）
- [ ] 用户B收到好友请求，可以接受或拒绝
- [ ] 查看好友列表
- [ ] 查看好友在线状态
- [ ] 好友上线/下线通知

**数据存储扩展**：
- `friendships(user_id, friend_id, status, created_at)`
- status: "pending", "accepted", "blocked"

**消息协议扩展**：
```json
// 添加好友
{"type": "add_friend", "username": "Bob"}

// 好友请求通知
{"type": "friend_request", "from": "Alice"}

// 接受/拒绝好友请求
{"type": "accept_friend", "from": "Alice"}
{"type": "reject_friend", "from": "Alice"}

// 查看好友列表
{"type": "list_friends"}

// 好友状态更新
{"type": "friend_online", "username": "Bob"}
{"type": "friend_offline", "username": "Bob"}
```

**验收标准**：
- 用户A添加B为好友，B收到请求
- B接受后，双方都在对方的好友列表中
- 好友上线/下线时，对方收到通知

**技术要点**：
- 关系型数据管理
- 双向关系处理
- 状态同步

---

### 📌 版本 0.7：群聊系统
**目标**：实现基于好友关系的群聊功能

**功能点**：
- [ ] 用户可以创建群聊（如 `/create_group_chat 我的群`）
- [ ] 创建者可以邀请好友加入群聊
- [ ] 群成员可以发送消息，所有成员收到
- [ ] 查看群成员列表
- [ ] 退出群聊

**数据存储扩展**：
- `group_chats(id, name, creator_id, created_at)`
- `group_members(group_id, user_id, joined_at)`

**消息协议扩展**：
```json
// 创建群聊
{"type": "create_group_chat", "name": "我的群"}

// 邀请好友加入
{"type": "invite_to_group", "group_id": 1, "username": "Bob"}

// 群聊消息
{"type": "group_chat_message", "group_id": 1, "from": "Alice", "message": "大家好"}

// 查看群成员
{"type": "list_group_members", "group_id": 1}
```

**验收标准**：
- 用户A创建群聊，可以邀请好友B和C
- A、B、C在群聊中发消息，其他成员都能收到
- 可以查看群成员列表

**技术要点**：
- 多对多关系管理（用户-群聊）
- 权限管理（创建者权限）
- 消息路由到特定群组

---

### 📌 版本 0.8：功能完善与优化
**目标**：完善功能，提升用户体验和代码质量

**功能点**：
- [ ] 错误处理和友好提示
- [ ] 消息历史记录（可选）
- [ ] 用户状态（在线/离线/忙碌）
- [ ] 消息时间戳格式化
- [ ] 代码重构和优化
- [ ] 基础单元测试

**验收标准**：
- 所有错误情况都有明确的提示
- 代码结构清晰，易于扩展
- 性能测试：支持至少100个并发连接

---

## 技术栈建议

### 推荐方案（按难度排序）

1. **Go + WebSocket**
   - 优势：并发模型简单（Goroutine），性能好，适合游戏服务器
   - 库：`gorilla/websocket` 或 `gobwas/ws`

2. **Node.js + WebSocket**
   - 优势：开发快速，生态丰富
   - 库：`ws` 或 `socket.io`

3. **Python + WebSocket**
   - 优势：语法简单，适合快速原型
   - 库：`websockets` 或 `tornado`

### 客户端建议

- **命令行客户端**：最简单，专注于服务器逻辑
- **Web客户端**：HTML + JavaScript，可视化效果更好
- **两者都做**：验证服务器兼容性

---

## 开发建议

1. **每个版本独立开发**：完成一个版本并测试通过后，再进入下一个版本
2. **保持代码整洁**：每个版本都要重构，为下一个版本做准备
3. **重视协议设计**：消息协议是核心，设计时要考虑扩展性
4. **先实现功能，再优化性能**：先让功能跑起来，再考虑性能优化
5. **写测试**：至少为关键功能写单元测试

---

## 验收清单

完成所有版本后，你应该能够：

- ✅ 理解 Socket 编程和连接管理
- ✅ 掌握消息广播机制
- ✅ 理解状态管理（内存 vs 持久化）
- ✅ 设计可扩展的消息协议
- ✅ 实现基本的用户系统和关系管理
- ✅ 处理并发和异步操作

---

**开始你的第一个版本吧！** 🚀 